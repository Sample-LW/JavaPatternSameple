package Structural.Decorator;

public class DecoratorMain {

//	StarDecorator decorator = new StarDecorator(new ChristmasTree());
	/*
	 * This is a very abstract example and could not be implemented in terms of code fully. But, then, as I have said, 
	 * I want you to understand the patterns rather than giving you concrete examples. 
	 * Once the pattern is internalized, you can think of some good software examples yourself.
Decorators, Composites and Adapters
The decorator and adapter patterns are similar. Adapters also seem to decorate the classes. 
The intent of using adapter is to convert the interface of one or more classes to suit the interface of the client program.
 In case of decorator, the intent is to add behavior and functionality to some of the objects,
not all the objects or adding different functionalities to each of the objects.

In case of composite objects, the client program treats the objects similarly, whether it is a simple or complex object (nodes).

The decorator pattern provides functionality to objects in a more flexible way rather than inheriting from them.

There is however disadvantage of using decorator. The disadvantage is that the code maintenance can be a problem as it provides 
the system with a lot of similar looking small objects (each decorator).
	 */
}
